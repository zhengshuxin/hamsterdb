I Am Legend:

Items are sorted by priority (highest on top).
o a pending  TODO item (for the current release)
. a pending  TODO item (for future releases)
x a finished TODO item

-----------------------------------------------------------------------------
This Branch Is About Integrating The hamsterdb2 Functionality!!!!!
-----------------------------------------------------------------------------
The big headline is:
As a user i want to run many Transactions in parallel with high performance.
I'm using multiple threads b/c my CPU has multiple cores, and expect hamsterdb
to scale with the number of cores.
==============================================================================

high-level plan for 2.1.4 ..................................................
x check for scalability issues with files > 1 GB
x improvements for ham_bench
- get rid of the freelist
- support pages of different sizes
- improved (faster) logging
- delta updates (maybe)
-----------------------------------------------------------------------------

x update copyright string: 2013 -> 2014

x check for scalability issues with files > 1 GB and check if we're on the
    right track regarding scalability
    -> remove the freelist
    -> add delta updates to avoid memmove in the index pages

x ham_bench: new test mode: first load with LOTS of data, then erase in the
    same order (or in random order or reverse order) till the database is empty
    - implementation idea: when switching to ERASE, perform a reset() on the
        NumberGenerator, and it will start delivering the same sequence as
        from the beginning
    x add a reset() method to the datasources
    x new command line options --bulk-erase
        x if set then reset() datasource, delete
        x NOT for parser-generator (print error)
        x only for stop-ops
    x add to monster tests

x get rid of the freelist for pages (not yet for blobs)
    The PageManager keeps a (persistent) list of all pages, including their
    id, their size, the type, the database. It keeps a separate list with
    all free pages.
    x the PageManager has a list of all pages. this effectively replaces
        the cache
    x the PageManager knows if a page is old or not, and whether it can
        be flushed to disk
    x get rid of the "totallist" linked list of all pages
    x get rid of the "bucket" linked list of all pages
    x remove HAM_CACHE_FULL and HAM_CACHE_STRICT - don't think it is used
    x the PageManager knows whether a page is free or not
        x no longer use the freelist to manage empty pages, only for blobs
    x when allocating new pages: check the internal list, not the freelist
    x store the modified list on disk, load it
        x implement store/load methods
        x store blob-id in the environment header 
        x load when env is opened
        x store when env is closed
        x PageManager must accept entries which are available but do not
            have a Page pointer
        x fix unittests
    x pax-layout with recsize == 0: must be much faster now
        -> yes, but purge_cache requires 30% of the time now
        x re-introduce totallist
    x move the unittests from cache.cpp to page_manager.cpp, update them
    x do not persist state if Environment is in-memory 
    x re-activate unittests in log.cpp
    x if logging is enabled: immediately write the modified state
        (later this will be rewritten as incremental updates for the log)
        x verify recovery tests

==================================

I do not like how the PM currently stores its state. Its data should be
separated from the rest, otherwise we run again into difficult situations
when the Environment is shut down.

Suggestion:
- store state in a linked list of pages. each database stores its pages (index
    AND blobs) in groups, and each group stores its state in one of those
    linked pages. the size of a group therefore depends on how much
    information fits into such a page (guestimate: over 700). 
    - advantage: dropping a database just means that all PageGroups of this
        database are dropped
    - complexity: the PM has to manage those groups
    - each PageGroup is responsible for its freelist management
    - it can also handle pages of different sizes and logical page IDs
    - if the PM state is modified then only the relevant PageGroup will
        be logged (in their surrounding Transaction)

==================================

o support pages with different sizes
    o each database can have a different size, but the size is constant
        for all pages from this database (for now)
        o page stores its size non-persistently
        o remove env->get_page_size(), device->get_page_size()
    o each blob page has a size of 1 MB (default), but can be larger
        o blob page stores size in its blob page-header
    o PageManager state does not need to store space for pages with default
        size

    o PageManager->is_cache_full() must take the sizes in account
    o make sure that the log can work with different sizes
    o if a free page is deleted then delete the Page pointer, but keep the
        entry in the map, otherwise we lose the information whether the page
        is free
    o when allocating a page: check freelist for pages with this size
    o make database header page much smaller (1 kb?)

o blob pages track their own freelist in the page itself
    o very large blob pages no longer span multiple blobs but create a
        single page which is large enough
        (as a result, EVERY blob page has now a header!)
    o blob: remove direct I/O - it's not used anyway
    o need a counter with the number of free bytes left
    o keep the actual freelist VERY simple - i.e. do not merge empty
        blobs, only store the 32 largest free entries etc
    o The PageManager knows where to find free sizes - but make sure that it
        does not store too much data!
    o completely get rid of the freelist
    o re-activate unittests in freelist.cpp (if it makes sense)
        o implement/update reclaim_space()
        o try to have a clean solution for the chicken/egg problem (the
            PageManager writes its state during shutdown, but this modifies
            its state) 
    o run performance tests

o verify/improve performance of btree_impl_default: it has a very high
    number of page splits compared to 2.1.3, even if the key size is <= 21.
    Why? maybe the capacity is not calculated correctly. or do keys have
    more overhead than in 2.1.3?

o web-page requires updates
    o deployed html differs from git-repository
    o www1
        o merge git repository of www1 (host on github, keep remote branch)
        o clean up 'dl' directory
        o where to host static files?
        o backup and deploy to www2, use round-robin DNS

o support pages with different sizes (cont...)
    o databases can have different default sizes, depending on their
        configuration (same for blobs)
        - increase for large key sizes
        - increase for duplicate keys
        - increase for blob pages
    o merge adjacent free pages (or not?)
    o implement check_integrity() and add calls and asserts after modifications
    o remove HAM_PARAM_PAGE_SIZE parameter from ham_env_create
    o add HAM_PARAM_PAGE_SIZE_LOW, HAM_PARAM_PAGE_SIZE_HIGH parameter
        to ham_env_create_db
    o insert(): instead of splitting, a page can now also grow; this is an
        atomic operation in the PageManager, but also needs to be reflected
        in the log somehow?

o simplify header page handling
    o db root page has a fixed id (i.e. = db-name), no need to store ID
        in the env-header
    o if the header page is replaced: only the PageManager is updated!
    o the header page will become very small (1kb or less) and read-only, not
        logged for regular operations
    o clean up the code (getters/setters of the header page)

. improve integration of static code analysis in release process
    o try to become "oclint-clean"
    o try to become "coverity-clean"

o support efficient logging
    o merge journal and log into one single file
    o if file exceeds a threshold (100 mb): start a new file
    - the btree/data file is INDEPENDENT from the log! it has only atomic
        updates and might become out-of-sync with the actual log. This is by
        design and must not cause problems! this will later allow us to run
        "compactions" in background.
    - the log contains logical "streams", i.e. for PageManager, for each Page
        etc
    - the log writes checkpoints of those streams if the number of delta
        updates exceeds a threshold
    - the log buffers the data and only flushes/fsyncs when requested
        (TODO this needs to be clearly defined!)
    - the log can be compressed (PRO)
    - use incremental logging for PageManager modifications
    - whenever a Btree page is flushed, the log will contain a "flush" marker
        of this page (and the lsn of the last update which modified this page).
        this marker is stored in the log's PageManager stream
        (can this marker be stored in the page itself?)
    ? what about SMOs?
        they're performed atomically in the Btree by updating/allocating all
        pages, modifying them, updating the PageManager stream in the log
        and then switching atomically in the PageManager map
    ? a insert with a duplicate table or extended key is not atomic; how
        can we solve this?
    ? how is recovery performed?
        - read the last buffer from the last logfile (the tail contains a
            header)
        - uncompress, if it was compressed
        - ...?
    ? can this asynchronousness cause problems?
    ? when/how to fsync?

  - StreamContainer
    - a collection of static buffers (i.e. pages, header page) and streams;
      all stored in one file. each stream contains segments with a small
      header (stream-id, subject, lsn, number of buffers), one or more
      buffers (size, checksum?) and a trailer (last checkpoint of metadata,
      last checkpoint of page-manager)
    - buffers data before writing to file, but flushes (and fsyncs) on
        demand
    - implementation for in-memory remains empty
    - requests checkpoints from streams if there are too many delta updates
    - uses log-file switching: if one file overflows then switch to a second
        file, write checkpoints and continue
    - can maintain its own Stream where it stores its own state: the buffers
        that were written to disk, which streams are in these buffers,
        are they obsolete through newer checkpoints etc
    - use this information to garbage-collect buffers and re-use them
    - add to LocalEnvironment
    - vacuum: ask all streams to perform checkpoints, and flush the buffer
        into a separate file; then rename the file 
    - move the Environment's configuration to a separate object
    - move the Database's configuration to a separate object

  - StreamContainer ("sc") #2
    - perform full transition by moving the remaining modules to the sc
    - pages: fetch/flush from sc file
    - journal: write to sc stream
    - log: write to sc stream
    - remove the device classes

high-level plan for 2.1.6 ...................................................
- reduce the linked lists - they're hard to be updated with concurrent
    operations
- delta updates: very similar to the current TransactionOperations; however,
    the difference is that delta updates are part of a page, whereas
    TransactionOperations are part of a Transaction. The difference is more
    obvious when talking about recovery: delta updates are logged in the
    "stream" of a page, not of a Transaction. When loading a page, they can be
    reapplied immediately and the page will be valid.
    -> logging disabled: don't bother
    -> logging enabled: write delta updates to a (buffered) log; flush log
        when a Txn is committed
    -> if the log exceeds 100 mb: switch to the next log
    -> delete old log files when all their streams are checkpointed in a
        newer file
    -> if delta updates exceed <threshold>: request/write a checkpoint
    -> each stream knows which log file stores its latest checkpoint
    -> when the database is closed: write checkpoints of as many streams
        as possible, esp. if older logs contain delta updates (then the
        old log can be purged)
    -> each log has a trailer which lists the streams in the log; this
        can be used to purge the log efficiently

  - Delta updates (concurrent/atomic!)
    are like TransactionOperations but directly attached to a BtreeNode.
    the Transaction is separated from the updates; its only state is a name,
    the Tid and the flags (committed, aborted...)
    - Transactions are stored in a linear array, just like the pages
    - db_local.cc: local Transactions must be aborted if a Transaction occurs
        (create them on the stack, abort in destructor)
    - Transactions are not connected to their operations or anywhere else
    - the TransactionOperation becomes a DeltaUpdate
    - attach the DeltaUpdate directly to the BtreeNode
    - the TransactionIndex is no longer required
    - fix insert/erase/find/cursor operations and do not use
        the TransactionIndex (rename BtreeIndex -> Btree)
    - the cursor can be directly coupled to a DeltaUpdate
    - implement SMOs (split/shifts/merge) and make sure the DeltaUpdates are
        moved to the other page, if necessary
    - when checkpointing: delete all DeltaUpdates that belong to an
        aborted Transaction (the Checkpoint is performed by the PageManager,
        which has to traverse the Btree because an SMO is performed
        recursively)
    - non-transactional updates are also performed as DeltaUpdates, but
        they are not logged

- bloom filter -> PRO
- compress the whole LSS (and the log) with snappy -> PRO
- encrypt the whole LSS (and the log) with AES -> PRO
- hot backups (vacuumizes to a different file) -> PRO
- compression -> PRO
- bulk updates -> PRO
    - give users API to allocate memory for keys/records
    - if user says that data is already sorted then do not re-sort
    - add those delta updates to the txn-trees or to the stream
- cache-oblivious page distribution? (maybe write the LSS first?)
    http://supertech.csail.mit.edu/cacheObliviousBTree.html
- first PRO release
    o webpage updates, PR, mailings
- concurrency
- operations on compressed data (COUNT(), MIN(), MAX(), ...)?
- C-Store style projections? (requires complex schema types)
    - introduce a new library with complex schema types, projections
    - analytic functions
        count, min, max, sum, product, average, ln, sqrt, exp, round, trunc,
        date/time functions and interval functions
    - select(predicate_t, column_descriptor_t, select_state_t)
             \- an AST of functors
                          \- existing columns or generated columns (i.e. sum())
                                                \- keeps track of offset, count
    - erase(predicate_t)
    - explain(predicate_t, column_descriptor_t)

o introduce PRO version
    o start a closed repository
    o one source base with different licensing headers, different licensing
        string (also for tools), different version tag
    o API to get licensee information (is_pro_version())
    o new release process
    o prebuilt win32 files
    o get rid of serial.h - it's not really required and only creates efforts
    o how to share files with customers? need a login area,
        downloadable, customized files (win32, serial.h, tarballs...)
        -> send out mails if a new file is available
    o evaluation license: build binaries for the most common architectures
        o insert expiration date checks
        o special copyright strings
        o prebuilt for win32/win64
        o unix: obfuscated source code
        o need an automated flow for signups, for evaluation licenses etc
    o extra documentation
    o define file format interoperability?
    o what are the minimum features required for the first release?
        - (evaluation licenses)
        - prefix compression for strings
        - lightweight compression for binary keys
        - SIMD for searches
        - AES encryption
        - hot backups

o PRO: btree can compress keys
    x get rid of the whole minkey/maxkey handling because these numbers
        are irrelevant with compression
    o try to reduce the changes to a new KeyProxy object
    o prefix-compression for strings
        o each 2kb have a full string (indexed by skiplist)
    o delta-compression for numeric data types (>= 32bit)
        (can this be combined with a bitmap compression? the deltas are
        compressed in a bit-stream? but then we end up with variable
        length encodings...)
    o lightweight compression for keys
        http://oldhome.schmorp.de/marc/liblzf.html
        http://lzop.org
    o record compression for blobs (lzop.org? snappy?)
        better postpone this and compress all pages in the lss
    o do we need delta updates for efficient inserts? - i think not yet...

o PRO: use SIMD for fixed-length scans and __builtin_prefetch
    o use valgrind to track cache misses
    http://pcl.intel-research.net/publications/palm.pdf
    http://www.cs.toronto.edu/~ryanjohn/teaching/csc2531-f11/slides/Ioan-SIMD-DBMS.pdf
    http://gcc.gnu.org/onlinedocs/gcc-3.3.6/gcc/Other-Builtins.html
    http://stackoverflow.com/questions/8460563/builtin-prefetch-how-much-does-it-read
    http://tomoyo.sourceforge.jp/cgi-bin/lxr/source/include/linux/prefetch.h
    http://stackoverflow.com/questions/7327994/prefetching-examples
    o use linear search with fixed length keys (if max-keys-per-page
        or the subrange in the binary search is low enough, and if the
        performance makes sense) -> also for MIT
    o if both layouts use binary search then move it back to the proxy!

o release-v2.pl: add test without berkeleydb

o use cache-oblivious b-tree layout
    o see roadmap document for more information
    o run a performance test/prototype if this is worth the effort
        o allocate a fixed number of pages (20) for the index
        o PageManager: when allocating a new page then use the distribution
            function to fetch a page from the reserved storage
    o this feature is *per database*
    o calculate number of reqd pages based on estimated keys from the user
    o make sure that this is not reverted when "reduce file size" feature
        (above) is enabled
    o the new pages are not managed by the freelist! therefore the freelist
        will not need any modifications
    . try to batch allocations; when new pages are required then don't just
        allocate one but multiple pages (if the database is big enough)

. clean up approx. matching
    o ONLY for cursors
    o Flags: HAM_FIND_LT_MATCH | HAM_FIND_GT_MATCH | HAM_FIND_EQ_MATCH (default)
    o lookup: the cursor is coupled to the key, even if the lookup fails
        then perform a lookup:
            found_key == requested_key:
                HAM_FIND_EQ_MATCH: ok
                HAM_FIND_LT_MATCH: return move_prev()
                HAM_FIND_GT_MATCH: return move_next()
            found_key < requested_key:
                HAM_FIND_LT_MATCH: ok
                HAM_FIND_GT_MATCH: return move_next()
                HAM_FIND_EQ_MATCH: key not found
            found_key > requested_key:
                HAM_FIND_GT_MATCH: ok
                HAM_FIND_LT_MATCH: return move_prev()
                HAM_FIND_EQ_MATCH: key not found
    o must work with transactions
    o do not store key flags; the caller has to compare the key
    o remove ham_key_set_intflags, ham_key_get_intflags, key->_flags (?)

. win32: need a release-v2.pl which fully automates the various release steps
    o delete all generated protobuf files
    o build for msvc 2008
    o run unittests for debug and release
    o run samples
    o delete all generated protobuf files
    o build for msvc 2010
    o run unittests for debug and release
    o run samples
    o build release package

. also remove locking from C# and Java APIs

------------------- idea soup ---------------------------------------------

o btree_impl_default::set_record: if the duplicate is LAST of the last key
    in the node then simply append the record and increase next_offset

o asynchronous prefetching of pages
    -> see posix_fadvice, libprefetch

o flush transactions in background (when the btree is concurrent)

o Improve leaf pages caching
    Store start/end key of each leaf page in a separate lookup table in order
    to avoid btree traversals. This could be part of the hinter.
  - one such cache per database
  - should work for insert/find/erase

o allow transactions w/o journal

o allow transactions w/o recovery

o when recovering, give users the choice if active transactions should be
    aborted (default behavior) or re-created
    o needs a function to enumerate them

o when flushing the Changeset: batch ALL changes for the WHOLE transaction,
    then flush all of them together. This way we can "merge" multiple changes
    for the same page.
    Also review the whole flush process - when not to log etc.
    - only 1 page affected: no need to log it because it is idempotent
    - freelist pages are always idempotent
    - more than 1 index page? not idempotent (most likely)
    - more than 1 blob page? not idempotent (maybe)
    o define a few benchmarks
    o be careful: if N operations are modifying the same changelog, and
        then #N+1 aborts then the aborting operation must NOT clear the
        changelog!

o A new transactional mode: read-only transactions can run "in the past" - only
    on committed transactions. therefore they avoid conflicts and will always
    succeed.

o changeset: instead of simply adding pages to the changeset, the caller
    could already specify whether this page needs logging or not;
    i.e. after freelist rewrite, the blob pages do not need logging if a
    blob is deleted  

o is there a way to group all changeset flushes of a Transaction into one
    changeset, and batch-commit multiple commits? that way we would avoid the
    frequent syncs and performance would be improved
    o would have to remove all of assert(changeset.is_empty())
    o but we can use that assert prior to txn_begin

o flush in background (asynchronously)
    o need new flag file HAM_DISABLE_ASYNCHRONOUS_FLUSH
    o if in-memory database: disable async flush
    o if transactions are disabled: disable async flush
    o if enabled: create background thread, wait for signal
    o ham_env_flush: if txn are enabled then try to flush them to disk
    o how to deal with an error in the background thread???
        o store in Environment, then return in every exported function
    o default: async flush is OFF!

    o extend monster tests
        o with async flush
        o without async flush
        o extend/run performance test
        o run monster tests

    o documentation
        o tutorial
        o faq

o need a function to get the txn of a conflict (same as in v2)
    ham_status_t ham_txn_get_conflicting_txn(ham_txn_t *txn, ham_txn_t **other);
        oder: txn-id zurückgeben? sonst gibt's ne race condition wenn ein anderer
        thread "other" committed/aborted
    o also add to c++ API
    o add documentation (header file)
    o add documentation (wiki)

. new test case for cursors
    insert (1, a)
    insert (1, b) (duplicate of 1)
    move (last) (-> 1, b)
    insert (1, c)
    move (last) (-> 1, c)? is the dupecache updated correctly?

. there are a couple of areas where a btree cursor is uncoupled, just to
    retrieve the key and to couple the txn-key. that's not efficient
        db.c:__btree_cursor_points_to
        db.c:__compare_cursors
        txn_cursor.c:cursor_sync
        txn_cursor.c:cursor_overwrite
    o move to a separate function
    o try to optimize

. add tests to verify that the cursor is not modified if an operation fails!
    (in cursor.cpp:LongTxnCursorTest are some wrapper functions to move or
    insert the cursor; that's a good starting point)

. new flag for transactions: HAM_TXN_WILL_COMMIT
    if this flag is set, then write all records directly to the file, not
    to the log. the log will only contain the rid.
    -> or: make this the default; call the new flag HAM_TXN_MAYBE_WILL_ABORT
    o in case of an abort: move the record to the freelist
    -> this affects all temporary ham_insert-transactions
    (not sure if this should get high priority)

. if memory consumption in the txn-tree is too high: flush records to disk
    (not sure if this should get high priority)

o ham_get_count: could be atomically updated with every journal entry

=======
>>>>>>> Updated TODO
